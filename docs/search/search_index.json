{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quickstart git clone git@github.com:korsimoro/k-bashenv ~/.k-bashenv Concept and Purpose The kbash environment may be useful when rapidly investigating and hacking around multiple projects across diverse technologies. In such a context, it is often useful to write a one-off shell script that you expect to use once-or twice, but often wind up using for a while. The kbash environment is a Convention-based toolkit which organizes these one-off bits of knowledge, until such time as they can be integrated into the mainstream build environment (at which time the kbash environment can be pruned.) The kbash environment aims to be the grease-in-the-gears, where accumulation of project-specific structure and knowledge should be continuously migrated out of the kbash environment. kbash should be a value-added utility, not a solution in itself. When to use project-discovery For mature projects, the roll of kbash should be reduced substantially. The kbash environment exists to support exploration, and the documented accretion of devops knowledge in the form of bash snippets, operating against a rich field of structure, utilities, and variables. multi-project If a project consists of a blending of multiple sub-projects, and the investigation of an complex build. Once the complex build is well understood, the knowledge accumulated in kbash scripts should be migrated into the more mature build systems of the sub-projects. Drivers environment-coupling Rather than being confined to operations on the filesystem, kbash allows systematic use of the shell environment. This is similar to - python venv - virtual environments for python - nvm - virtual environments for node - rvm - virtual environments for ruby Environmental coupling is accomplished through the use of bash function sets which are integrated into the control, help, and convention systems. multiple-concurrency Multiple kbash environments can co-exist, as all shell variables, including the entry point, are scoped by prefixes - SHELL_PREFIX - this is the entrypoint, and is used to prefix all project specfic information. environment-isolation Often, when developing node or python systems, each has an active set of CLI entrypoints which are required by the repository. Many build systems rely on system deployments. While solutions like docker are excellent at capturing these dependencies, there is often a lengthy task of figuring out how to combine those solutions into a docker image, as well as making decisions about which solution flavor to include. The kbash environment is useful in capturing this information, through the use of appropriate environment variables which are unique to a given sub-project. consistent scripting environment Many useful patterns in bash scripting are rather arcane. kbash wraps these in more intent-expressive labels. dynamic-reload Talk about kd reset and ACTIVATION_COUNT and prompt dynamic-assignment Talk about loading via Eval via boot.sh Theory of Operation $PROJECT specific activation What is a $PROJECT A project is a kbash environment coupled to a specific based directory, known internally as $VAR_PREFIX , where the VAR_PREFIX variable is the base of the $PROJECT Keep in mind that VAR_PREFIX is not the name of the variable, rather it is the name of the name of the variable. So, for example, in the kx test project, KXX is the VAR_PREFIX and $KXX evaluates to the base of the kx project. What happens Activate a shell by executing . $PROJECT/activate.sh , which applies the environment to the current shell, or $PROJECT/shell.sh which spawns a subshell with the $PROJECT environment activated. The . $PROJECT/activate.sh command sets the project base directory and invokes $KBASH/util/api/boot.sh . Sourcing boot.sh causes the following to occur, where all shell input files are sed filtered to replace two strings: SHELL_PREFIX , which is used to prefix all kbash environment elements. For example, if your entrypoint is kx then all of the functions involved in this environment should be prefixed with kx_ . Access to the environment is then acquired by running commands prefixed with kx , such as kx build project3 VAR_PREFIX , which is used to scope all variables associated with the top level build environment. Often, the SHELL_PREFIX does not scan well in variable assignments. In the kx test case, the value of VAR_PREFIX is KXX , meaning that all environment variables associated with the $PROJECT are prefixed with KXX_ The following global variables are set during invocation Pos Variable Purpose $1 SHELL_PREFIX scopes functions $2 VAR_PREFIX scopes variables $3 USER_UTIL_LOAD_LIST loaded, in order, from $PROJECT $4 SYSTEM_UTIL_LOAD_LIST loaded, in order, from $K_BASHENV_BASE Directory Layout api The API is defined by - SHELL_PREFIX - VAR_PREFIX State: Variable Value VAR_PREFIX VAR_PREFIX_BASH $VAR_PREFIX/bashenv VAR_PREFIX_KBASH_LOGS $VAR_PREFIX/kbash-logs VAR_PREFIX_BASH_COMMAND $VAR_PREFIX_BASH/commands VAR_PREFIX_FUNCTION_LIST VAR_PREFIX_BASH_FUNCTION $VAR_PREFIX_BASH/functions VAR_PREFIX_COMPONENT_LIST VAR_PREFIX_COMPONENT_DIR $VAR_PREFIX_BASH/components api/boot.sh boot.sh is invoked with 4 positional arguments . <path-to-project-local-activate.sh> \\ \"SHELL_PREFIX\" \\ \"VAR_PREFIX\" \\ \"USER_UTIL_LOAD_LIST\" \\ \"SYSTEM_UTIL_LOAD_LIST\" About SHELL_PREFIX The shell prefix is the command line entry point used to access this environment. It is also used to scope all functions loaded into the shell. api/commands","title":"Home"},{"location":"#quickstart","text":"git clone git@github.com:korsimoro/k-bashenv ~/.k-bashenv","title":"Quickstart"},{"location":"#concept-and-purpose","text":"The kbash environment may be useful when rapidly investigating and hacking around multiple projects across diverse technologies. In such a context, it is often useful to write a one-off shell script that you expect to use once-or twice, but often wind up using for a while. The kbash environment is a Convention-based toolkit which organizes these one-off bits of knowledge, until such time as they can be integrated into the mainstream build environment (at which time the kbash environment can be pruned.) The kbash environment aims to be the grease-in-the-gears, where accumulation of project-specific structure and knowledge should be continuously migrated out of the kbash environment. kbash should be a value-added utility, not a solution in itself.","title":"Concept and Purpose"},{"location":"#when-to-use","text":"project-discovery For mature projects, the roll of kbash should be reduced substantially. The kbash environment exists to support exploration, and the documented accretion of devops knowledge in the form of bash snippets, operating against a rich field of structure, utilities, and variables. multi-project If a project consists of a blending of multiple sub-projects, and the investigation of an complex build. Once the complex build is well understood, the knowledge accumulated in kbash scripts should be migrated into the more mature build systems of the sub-projects.","title":"When to use"},{"location":"#drivers","text":"environment-coupling Rather than being confined to operations on the filesystem, kbash allows systematic use of the shell environment. This is similar to - python venv - virtual environments for python - nvm - virtual environments for node - rvm - virtual environments for ruby Environmental coupling is accomplished through the use of bash function sets which are integrated into the control, help, and convention systems. multiple-concurrency Multiple kbash environments can co-exist, as all shell variables, including the entry point, are scoped by prefixes - SHELL_PREFIX - this is the entrypoint, and is used to prefix all project specfic information. environment-isolation Often, when developing node or python systems, each has an active set of CLI entrypoints which are required by the repository. Many build systems rely on system deployments. While solutions like docker are excellent at capturing these dependencies, there is often a lengthy task of figuring out how to combine those solutions into a docker image, as well as making decisions about which solution flavor to include. The kbash environment is useful in capturing this information, through the use of appropriate environment variables which are unique to a given sub-project. consistent scripting environment Many useful patterns in bash scripting are rather arcane. kbash wraps these in more intent-expressive labels. dynamic-reload Talk about kd reset and ACTIVATION_COUNT and prompt dynamic-assignment Talk about loading via Eval via boot.sh","title":"Drivers"},{"location":"#theory-of-operation","text":"","title":"Theory of Operation"},{"location":"#project-specific-activation","text":"","title":"$PROJECT specific activation"},{"location":"#what-is-a-project","text":"A project is a kbash environment coupled to a specific based directory, known internally as $VAR_PREFIX , where the VAR_PREFIX variable is the base of the $PROJECT Keep in mind that VAR_PREFIX is not the name of the variable, rather it is the name of the name of the variable. So, for example, in the kx test project, KXX is the VAR_PREFIX and $KXX evaluates to the base of the kx project.","title":"What is a $PROJECT"},{"location":"#what-happens","text":"Activate a shell by executing . $PROJECT/activate.sh , which applies the environment to the current shell, or $PROJECT/shell.sh which spawns a subshell with the $PROJECT environment activated. The . $PROJECT/activate.sh command sets the project base directory and invokes $KBASH/util/api/boot.sh . Sourcing boot.sh causes the following to occur, where all shell input files are sed filtered to replace two strings: SHELL_PREFIX , which is used to prefix all kbash environment elements. For example, if your entrypoint is kx then all of the functions involved in this environment should be prefixed with kx_ . Access to the environment is then acquired by running commands prefixed with kx , such as kx build project3 VAR_PREFIX , which is used to scope all variables associated with the top level build environment. Often, the SHELL_PREFIX does not scan well in variable assignments. In the kx test case, the value of VAR_PREFIX is KXX , meaning that all environment variables associated with the $PROJECT are prefixed with KXX_ The following global variables are set during invocation Pos Variable Purpose $1 SHELL_PREFIX scopes functions $2 VAR_PREFIX scopes variables $3 USER_UTIL_LOAD_LIST loaded, in order, from $PROJECT $4 SYSTEM_UTIL_LOAD_LIST loaded, in order, from $K_BASHENV_BASE","title":"What happens"},{"location":"#directory-layout","text":"","title":"Directory Layout"},{"location":"#api","text":"The API is defined by - SHELL_PREFIX - VAR_PREFIX State: Variable Value VAR_PREFIX VAR_PREFIX_BASH $VAR_PREFIX/bashenv VAR_PREFIX_KBASH_LOGS $VAR_PREFIX/kbash-logs VAR_PREFIX_BASH_COMMAND $VAR_PREFIX_BASH/commands VAR_PREFIX_FUNCTION_LIST VAR_PREFIX_BASH_FUNCTION $VAR_PREFIX_BASH/functions VAR_PREFIX_COMPONENT_LIST VAR_PREFIX_COMPONENT_DIR $VAR_PREFIX_BASH/components","title":"api"},{"location":"#apibootsh","text":"boot.sh is invoked with 4 positional arguments . <path-to-project-local-activate.sh> \\ \"SHELL_PREFIX\" \\ \"VAR_PREFIX\" \\ \"USER_UTIL_LOAD_LIST\" \\ \"SYSTEM_UTIL_LOAD_LIST\" About SHELL_PREFIX The shell prefix is the command line entry point used to access this environment. It is also used to scope all functions loaded into the shell.","title":"api/boot.sh"},{"location":"#apicommands","text":"","title":"api/commands"}]}