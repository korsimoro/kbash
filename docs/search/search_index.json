{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quickstart Proof of Concept This will verify that the system is operational by dropping you into a shell git clone git@github.com:korsimoro/kbash ~/.kbash echo \"kx\" | ~/.kbash/test/sanity.sh Bootstrap This is how you bootstrap a new environment git clone git@github.com:korsimoro/kbash ~/.kbash ~/.kbash/setup.sh <ENTRYPOINT> <VARSCOPE> <DIRECTORY> <DIRECTORY>/shell.sh Argument Description ENTRYPOINT This is the name of the command introduced into the environment, and the prefix on all defined shell assets (functions, internal variables) VARSCOPE This is the prefix attached to all public variables used to describe and control the environment DIRECTORY This is the directory in which the new kbash environment is to be set up Troubleshooting Terminology and Core Ideas What is a $PROJECT A project is a kbash environment coupled to a specific base directory, known internally as $VAR_PREFIX , where the VAR_PREFIX variable is the base of the $PROJECT Keep in mind that VAR_PREFIX is not the name of the variable, rather it is the name of the name of the variable. So, for example, in the kx test project, KXX is the VAR_PREFIX and $KXX evaluates to the base of the kx project. Commands and Functions Utility files and Language Support Components Concept and Purpose The kbash environment may be useful when rapidly investigating and hacking around multiple projects across diverse technologies. In such a context, it is often useful to write a one-off shell script that you expect to use once-or twice, but often wind up using for a while. The kbash environment is a Convention-based toolkit which organizes these one-off bits of knowledge, until such time as they can be integrated into the mainstream build environment (at which time the kbash environment can be pruned.) The kbash environment aims to be the grease-in-the-gears, where accumulation of project-specific structure and knowledge should be continuously migrated out of the kbash environment. kbash should be a value-added utility, not a solution in itself. The kbash environment supports bash ing code into behaviour, adapting to local conditions, and exploring what needs to be done to move projects to the next level - without hampering the developer with the need to get the dev-env working first. When to use project-discovery For mature projects, the roll of kbash should be reduced substantially. The kbash environment exists to support exploration, and the documented accretion of devops knowledge in the form of bash snippets, operating against a rich field of structure, utilities, and variables. multi-project If a project consists of a blending of multiple sub-projects, and the investigation of an complex build. Once the complex build is well understood, the knowledge accumulated in kbash scripts should be migrated into the more mature build systems of the sub-projects. Drivers environment-coupling Rather than being confined to operations on the filesystem, kbash allows systematic use of the shell environment. This is similar to - python venv - virtual environments for python - nvm - virtual environments for node - rvm - virtual environments for ruby Environmental coupling is accomplished through the use of bash function sets which are integrated into the control, help, and convention systems. multiple-concurrency Multiple kbash environments can co-exist, as all shell variables, including the entry point, are scoped by prefixes - ENTRYPOINT - this is the entrypoint, and is used to prefix all project specfic information. environment-isolation Often, when developing node or python systems, each has an active set of CLI entrypoints which are required by the repository. Many build systems rely on system deployments. While solutions like docker are excellent at capturing these dependencies, there is often a lengthy task of figuring out how to combine those solutions into a docker image, as well as making decisions about which solution flavor to include. The kbash environment is useful in capturing this information, through the use of appropriate environment variables which are unique to a given sub-project. consistent scripting environment Many useful patterns in bash scripting are rather arcane. kbash wraps these in more intent-expressive labels. dynamic-reload Talk about kd reset and ACTIVATION_COUNT and prompt dynamic-assignment Talk about loading via Eval via boot.sh When not use make-replacement The kbash environment is not a make replacement yarn-replacement The kbash environment is not a yarn replacement npm-replacement The kbash environment is not a npm replacement lerna-replacement The kbash environment is not a lerna replacement","title":"Home"},{"location":"#quickstart","text":"","title":"Quickstart"},{"location":"#proof-of-concept","text":"This will verify that the system is operational by dropping you into a shell git clone git@github.com:korsimoro/kbash ~/.kbash echo \"kx\" | ~/.kbash/test/sanity.sh","title":"Proof of Concept"},{"location":"#bootstrap","text":"This is how you bootstrap a new environment git clone git@github.com:korsimoro/kbash ~/.kbash ~/.kbash/setup.sh <ENTRYPOINT> <VARSCOPE> <DIRECTORY> <DIRECTORY>/shell.sh Argument Description ENTRYPOINT This is the name of the command introduced into the environment, and the prefix on all defined shell assets (functions, internal variables) VARSCOPE This is the prefix attached to all public variables used to describe and control the environment DIRECTORY This is the directory in which the new kbash environment is to be set up","title":"Bootstrap"},{"location":"#troubleshooting","text":"","title":"Troubleshooting"},{"location":"#terminology-and-core-ideas","text":"","title":"Terminology and Core Ideas"},{"location":"#what-is-a-project","text":"A project is a kbash environment coupled to a specific base directory, known internally as $VAR_PREFIX , where the VAR_PREFIX variable is the base of the $PROJECT Keep in mind that VAR_PREFIX is not the name of the variable, rather it is the name of the name of the variable. So, for example, in the kx test project, KXX is the VAR_PREFIX and $KXX evaluates to the base of the kx project.","title":"What is a $PROJECT"},{"location":"#commands-and-functions","text":"","title":"Commands and Functions"},{"location":"#utility-files-and-language-support","text":"","title":"Utility files and Language Support"},{"location":"#components","text":"","title":"Components"},{"location":"#concept-and-purpose","text":"The kbash environment may be useful when rapidly investigating and hacking around multiple projects across diverse technologies. In such a context, it is often useful to write a one-off shell script that you expect to use once-or twice, but often wind up using for a while. The kbash environment is a Convention-based toolkit which organizes these one-off bits of knowledge, until such time as they can be integrated into the mainstream build environment (at which time the kbash environment can be pruned.) The kbash environment aims to be the grease-in-the-gears, where accumulation of project-specific structure and knowledge should be continuously migrated out of the kbash environment. kbash should be a value-added utility, not a solution in itself. The kbash environment supports bash ing code into behaviour, adapting to local conditions, and exploring what needs to be done to move projects to the next level - without hampering the developer with the need to get the dev-env working first.","title":"Concept and Purpose"},{"location":"#when-to-use","text":"project-discovery For mature projects, the roll of kbash should be reduced substantially. The kbash environment exists to support exploration, and the documented accretion of devops knowledge in the form of bash snippets, operating against a rich field of structure, utilities, and variables. multi-project If a project consists of a blending of multiple sub-projects, and the investigation of an complex build. Once the complex build is well understood, the knowledge accumulated in kbash scripts should be migrated into the more mature build systems of the sub-projects.","title":"When to use"},{"location":"#drivers","text":"environment-coupling Rather than being confined to operations on the filesystem, kbash allows systematic use of the shell environment. This is similar to - python venv - virtual environments for python - nvm - virtual environments for node - rvm - virtual environments for ruby Environmental coupling is accomplished through the use of bash function sets which are integrated into the control, help, and convention systems. multiple-concurrency Multiple kbash environments can co-exist, as all shell variables, including the entry point, are scoped by prefixes - ENTRYPOINT - this is the entrypoint, and is used to prefix all project specfic information. environment-isolation Often, when developing node or python systems, each has an active set of CLI entrypoints which are required by the repository. Many build systems rely on system deployments. While solutions like docker are excellent at capturing these dependencies, there is often a lengthy task of figuring out how to combine those solutions into a docker image, as well as making decisions about which solution flavor to include. The kbash environment is useful in capturing this information, through the use of appropriate environment variables which are unique to a given sub-project. consistent scripting environment Many useful patterns in bash scripting are rather arcane. kbash wraps these in more intent-expressive labels. dynamic-reload Talk about kd reset and ACTIVATION_COUNT and prompt dynamic-assignment Talk about loading via Eval via boot.sh","title":"Drivers"},{"location":"#when-not-use","text":"make-replacement The kbash environment is not a make replacement yarn-replacement The kbash environment is not a yarn replacement npm-replacement The kbash environment is not a npm replacement lerna-replacement The kbash environment is not a lerna replacement","title":"When not use"},{"location":"layout/","text":"Repository Layout Subdirectories Dir Purpose api Subsystem exposed in consumer shells core Core bash abilities docs Documentation shipped on public site lang Specific Language Support (node, python, ruby, etc....) mkdocs Source for site docs setup Templates used in new environments test Utilities supporting test Executable Files File Purpose boot.sh Invoke to activate custom environment setup.sh Use to set up a new environment Utility Files Fjle Purpose os.sh Specific OS/Bash level adaptations Control Files Fjle Purpose README.md Use to set up a new environment LICENSE not yet present","title":"Layout"},{"location":"layout/#repository-layout","text":"","title":"Repository Layout"},{"location":"layout/#subdirectories","text":"Dir Purpose api Subsystem exposed in consumer shells core Core bash abilities docs Documentation shipped on public site lang Specific Language Support (node, python, ruby, etc....) mkdocs Source for site docs setup Templates used in new environments test Utilities supporting test","title":"Subdirectories"},{"location":"layout/#executable-files","text":"File Purpose boot.sh Invoke to activate custom environment setup.sh Use to set up a new environment","title":"Executable Files"},{"location":"layout/#utility-files","text":"Fjle Purpose os.sh Specific OS/Bash level adaptations","title":"Utility Files"},{"location":"layout/#control-files","text":"Fjle Purpose README.md Use to set up a new environment LICENSE not yet present","title":"Control Files"},{"location":"ops/","text":"Theory of Operation $PROJECT specific activation What happens Activate a shell by executing . $PROJECT/activate.sh , which applies the environment to the current shell, or $PROJECT/shell.sh which spawns a subshell with the $PROJECT environment activated. The . $PROJECT/activate.sh command sets the project base directory and invokes $KBASH/util/api/boot.sh . Sourcing boot.sh causes the following to occur, where all shell input files are sed filtered to replace two strings: ENTRYPOINT , which is used to prefix all kbash environment elements. For example, if your entrypoint is kx then all of the functions involved in this environment should be prefixed with kx_ . Access to the environment is then acquired by running commands prefixed with kx , such as kx build project3 VAR_PREFIX , which is used to scope all variables associated with the top level build environment. Often, the ENTRYPOINT does not scan well in variable assignments. In the kx test case, the value of VAR_PREFIX is KXX , meaning that all environment variables associated with the $PROJECT are prefixed with KXX_ The following global variables are set during invocation Pos Variable Purpose $1 ENTRYPOINT scopes functions $2 VAR_PREFIX scopes variables $3 USER_UTIL_LOAD_LIST loaded, in order, from $PROJECT $4 LANG_LOAD_LIST loaded, in order, from $KBASH","title":"Operations"},{"location":"ops/#theory-of-operation","text":"","title":"Theory of Operation"},{"location":"ops/#project-specific-activation","text":"","title":"$PROJECT specific activation"},{"location":"ops/#what-happens","text":"Activate a shell by executing . $PROJECT/activate.sh , which applies the environment to the current shell, or $PROJECT/shell.sh which spawns a subshell with the $PROJECT environment activated. The . $PROJECT/activate.sh command sets the project base directory and invokes $KBASH/util/api/boot.sh . Sourcing boot.sh causes the following to occur, where all shell input files are sed filtered to replace two strings: ENTRYPOINT , which is used to prefix all kbash environment elements. For example, if your entrypoint is kx then all of the functions involved in this environment should be prefixed with kx_ . Access to the environment is then acquired by running commands prefixed with kx , such as kx build project3 VAR_PREFIX , which is used to scope all variables associated with the top level build environment. Often, the ENTRYPOINT does not scan well in variable assignments. In the kx test case, the value of VAR_PREFIX is KXX , meaning that all environment variables associated with the $PROJECT are prefixed with KXX_ The following global variables are set during invocation Pos Variable Purpose $1 ENTRYPOINT scopes functions $2 VAR_PREFIX scopes variables $3 USER_UTIL_LOAD_LIST loaded, in order, from $PROJECT $4 LANG_LOAD_LIST loaded, in order, from $KBASH","title":"What happens"},{"location":"api/commands/","text":"These will be searched for and loaded on demand","title":"Commands"},{"location":"api/commands/#these-will-be-searched-for-and-loaded-on-demand","text":"","title":"These will be searched for and loaded on demand"},{"location":"api/functions/","text":"these are loaded into the shell","title":"Functions"},{"location":"api/functions/#these-are-loaded-into-the-shell","text":"","title":"these are loaded into the shell"},{"location":"api/intro/","text":"api The API is defined by - ENTRYPOINT - VAR_PREFIX Variables Where Set Variable Value VAR_PREFIX $( cd \"$( dirname \"${BASH_SOURCE[0]}\" )/..\" && pwd ) VAR_PREFIX_KBASH $KBASH/api/util/kbash/state.sh VAR_PREFIX_KBASH_LOGS $KBASH/api/util/kbash/state.sh VAR_PREFIX_KBASH_COMMAND $KBASH/api/util/kbash/state.sh VAR_PREFIX_FUNCTION_LIST $KBASH/api/util/kbash/state.sh VAR_PREFIX_KBASH_FUNCTION $KBASH/api/util/kbash/state.sh VAR_PREFIX_COMPONENT_LIST $KBASH/api/util/kbash/state.sh VAR_PREFIX_COMPONENT_DIR $KBASH/api/util/kbash/state.sh Initial Values Variable Value VAR_PREFIX $( cd \"$( dirname \"${BASH_SOURCE[0]}\" )/..\" && pwd ) VAR_PREFIX_KBASH $VAR_PREFIX/bashenv VAR_PREFIX_KBASH_LOGS $VAR_PREFIX/kbash-logs VAR_PREFIX_KBASH_COMMAND $VAR_PREFIX_KBASH/commands VAR_PREFIX_FUNCTION_LIST VAR_PREFIX_KBASH_FUNCTION $VAR_PREFIX_KBASH/functions VAR_PREFIX_COMPONENT_LIST VAR_PREFIX_COMPONENT_DIR $VAR_PREFIX_KBASH/components api/boot.sh boot.sh is invoked with 4 positional arguments . <path-to-project-local-activate.sh> \\ \"ENTRYPOINT\" \\ \"VAR_PREFIX\" \\ \"USER_UTIL_LOAD_LIST\" \\ \"SYSTEM_UTIL_LOAD_LIST\" About ENTRYPOINT The shell prefix is the command line entry point used to access this environment. It is also used to scope all functions loaded into the shell. api/commands","title":"Intro"},{"location":"api/intro/#api","text":"The API is defined by - ENTRYPOINT - VAR_PREFIX","title":"api"},{"location":"api/intro/#variables","text":"","title":"Variables"},{"location":"api/intro/#where-set","text":"Variable Value VAR_PREFIX $( cd \"$( dirname \"${BASH_SOURCE[0]}\" )/..\" && pwd ) VAR_PREFIX_KBASH $KBASH/api/util/kbash/state.sh VAR_PREFIX_KBASH_LOGS $KBASH/api/util/kbash/state.sh VAR_PREFIX_KBASH_COMMAND $KBASH/api/util/kbash/state.sh VAR_PREFIX_FUNCTION_LIST $KBASH/api/util/kbash/state.sh VAR_PREFIX_KBASH_FUNCTION $KBASH/api/util/kbash/state.sh VAR_PREFIX_COMPONENT_LIST $KBASH/api/util/kbash/state.sh VAR_PREFIX_COMPONENT_DIR $KBASH/api/util/kbash/state.sh","title":"Where Set"},{"location":"api/intro/#initial-values","text":"Variable Value VAR_PREFIX $( cd \"$( dirname \"${BASH_SOURCE[0]}\" )/..\" && pwd ) VAR_PREFIX_KBASH $VAR_PREFIX/bashenv VAR_PREFIX_KBASH_LOGS $VAR_PREFIX/kbash-logs VAR_PREFIX_KBASH_COMMAND $VAR_PREFIX_KBASH/commands VAR_PREFIX_FUNCTION_LIST VAR_PREFIX_KBASH_FUNCTION $VAR_PREFIX_KBASH/functions VAR_PREFIX_COMPONENT_LIST VAR_PREFIX_COMPONENT_DIR $VAR_PREFIX_KBASH/components","title":"Initial Values"},{"location":"api/intro/#apibootsh","text":"boot.sh is invoked with 4 positional arguments . <path-to-project-local-activate.sh> \\ \"ENTRYPOINT\" \\ \"VAR_PREFIX\" \\ \"USER_UTIL_LOAD_LIST\" \\ \"SYSTEM_UTIL_LOAD_LIST\" About ENTRYPOINT The shell prefix is the command line entry point used to access this environment. It is also used to scope all functions loaded into the shell.","title":"api/boot.sh"},{"location":"api/intro/#apicommands","text":"","title":"api/commands"},{"location":"api/util/","text":"these provide support utilities","title":"Util"},{"location":"api/util/#these-provide-support-utilities","text":"","title":"these provide support utilities"}]}