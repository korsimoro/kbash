{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The kbash project add-on is a set of bash utilities supporting knowledge capture and organizing ad-hoc plumbing. It is often useful in multi-component, multi-language software projects - especially if they use multiple build tools. And it can be useful in cobbling together disparate builds and systems to prototype components. Once a project suite is stabilzied the kbash functionality should be absorbed into specific, formal, project appropriate infrastructure. Quickstart The following commands verify that the system is operational. This sets up a new environment, runs a shell inside it, runs the default documentation command, and then exits the shell. git clone git@github.com:korsimoro/kbash ~/.kbash ~/.kbash/test/sanity.sh This will install a test environment and execute the entrypoint command to generate the default help output. Click here for example output You can find Documentation in the current docs directory, by opening the docs/index.html file with your local browser. Bootstrap Applying kbash to an existing project is easy. The following will add kbash support to your project, relying upon the global checkout for utility functions and separating project-specific configuration from generic utility core (typically in ~/.kbash ) git clone git@github.com:korsimoro/kbash ~/.kbash ~/.kbash/setup.sh <ENTRYPOINT> <VAR_PREFIX> <DIRECTORY> <DIRECTORY>/shell.sh The three variable listed above are described here: Argument Example Description ENTRYPOINT kb This is the name of the command introduced into the environment, and the prefix on all defined shell assets (functions, internal variables) VAR_PREFIX KB This is the prefix attached to all public variables used to describe and control the environment. DIRECTORY $PROJECT/kbash This is the directory in which the new, project specific, kbash environment is to be set up. Canonically it is in the kbash directory of your project. This directory exists in addition to the clone above. Development & Documentation If you are interested in developing or building kbash, please check out our Developers file. This talks about how to view and build the existing documentation. We use docker with MkDoc-Material A Cool Trick You can run a single command within a kbash environment, without influencing the external execution environment. echo \"kx manual\" | $BUILD_DOCS_BASE/../test/single.sh -i > $BUILD_DOCS_BASE/in/example-manual.md What is kbash and how would I use it? Many software projects, such as an npm package, or a python module, or a rust crate, or a ruby gem have sufficient support within the language environment for building and packaging code, for running tests, for linking documentation with the code base, etc. However, in complex, multi-language, multi-component projects, coordinating the different build environments often requires bits and pieces of glue which do not fit well in the language specific build systems. The kbash environment provides a way to organize those bits of logic as a set of shell functions and files. When rapidly investigating and hacking around multiple projects spanning diverse technology sets, it is often useful to write a one-off shell script that you expect to use once-or twice, but often wind up using for a while. The kbash environment is a Convention-based toolkit which organizes these one-off bits of knowledge, until such time as they can be integrated into the mainstream build environments - at which time the kbash environment should be pruned. kbash should be a value-added utility for temporary hacky-information capture, not a solution in itself. A final role of kbash is in capturing environmental integrity, sanity, and state checks. This is exactly the sort of utility you hope you never need, but which can greatly improve the ability to troubleshoot broken environments. Concepts A Project A kbash project consists of - a kbash directory within the project - a checkout of the korsimoro/kbash common library, typically ~/.kbash The common library provides utility functions and scripts which are not related to any specific project. All project specific data is located in the kbash project directory, typically at $PROJECT/kbash ENTRYPOINT command line tool Every project has a command line tool with subcommands, much like git . Interestingly, kbash takes the form of a bash function, which allows it to manipulate the current environment variables in cases when it is useful to do so, such as activating a python virtual environment, a node virtual environment, or some combination of environments (for example, a project using both a python venv and an nvm environment). Commands vs. Functions A key distinction must be made between bash functions and commands. Commands are executed as subprocesses, like any other command - meaning that the environment of the executing child process is isolated from the running shell. A subcommand can not, for example, change the current prompt. Functions, on the other hand, run within the current shell and as such they can modify the current environment. This is exploited by many of the language specific virtual environment managers and modern bash provides a tremendous amount of support for such scripting. On the other hand, with great power comes great responsibility - so every attempt is made to minimize the use of functions and limit their use to cases in which a modification of the environment is necessary. A common example of this distinction are cd and ls - cd is a bash-builtin which operates on the current environment, while ls is just a program that needs to be in the PATH . Components A kbash project is usually made up of multiple parts which need to be coordinated, and often which have a common lifecycle. For example, one project where kbash proved useful, used forks of two lerna-based monorepo typescript projects, two forks of python projects, one mixed python/typescript project, one project that built all of the above into an electron deliverable. In this case, each project was modeled as a component. Declaring a component is done simply, using this form ENTRYPOINT add-component [name] [var-prefix] Which sets up the following structure - creating what needs to be created and using existing elements (like directories) if present: What Description $PROJECT/kbash/components/[name] The place for your component functions & commands ENTRYPOINT [name] .... The cli hook $PROJECT/[name] The directory containing the component ${var-prefix}_BASE Variable pointing to the $PROJECT/[name] directory other default variables look in $PROJECT/kbash/components/[name]/describe.sh ENTRYPOINT [cfunc] [name] see the table below Standard Component Lifecycle Stage Description setup This performs functions like npm install , set up a python venv, install ruby gems, etc. clean This erases anything installed in setup activate This makes the environment constructed in setup the active environment describe This provides information about the environment build This triggers whatever is the standard build script for the component These are not strongly required - and, in fact, they are simply bash functions that get called and which obey a standard naming convention. The hope is that using add-component will pattern out a set of files, which can then be quickly edited, to capture the sort of information that is typically in the component's readme - for example, running npm install . In the table below, imagine that we have a project called ex with a single component called comp1 set up using: ~/.kbash/setup.sh ex EX /tmp/ex ex add-component comp1 COMP1 In this case, the following is set up CLI Function Where Defined ex build comp1 build_environment_ex_comp1 $EX/kbash/components/comp1/build.sh ex activate comp1 activate_environment_ex_comp1 $EX/kbash/components/comp1/activate.sh ex describe comp1 describe_environment_ex_comp1 $EX/kbash/components/comp1/describe.sh ex clean comp1 clean_environment_ex_comp1 $EX/kbash/components/comp1/clean.sh ex setup comp1 setup_environment_ex_comp1 $EX/kbash/components/comp1/setup.sh Old Notes When to use project-discovery For mature projects, the roll of kbash should be reduced substantially. The kbash environment exists to support exploration, and the documented accretion of devops knowledge in the form of bash snippets, operating against a rich field of structure, utilities, and variables. multi-project If a project consists of a blending of multiple sub-projects, and the investigation of an complex build. Once the complex build is well understood, the knowledge accumulated in kbash scripts should be migrated into the more mature build systems of the sub-projects. Drivers environment-coupling Rather than being confined to operations on the filesystem, kbash allows systematic use of the shell environment. This is similar to - python venv - virtual environments for python - nvm - virtual environments for node - rvm - virtual environments for ruby Environmental coupling is accomplished through the use of bash function sets which are integrated into the control, help, and convention systems. multiple-concurrency Multiple kbash environments can co-exist, as all shell variables, including the entry point, are scoped by prefixes - ENTRYPOINT - this is the entrypoint, and is used to prefix all project specfic information. environment-isolation Often, when developing node or python systems, each has an active set of CLI entrypoints which are required by the repository. Many build systems rely on system deployments. While solutions like docker are excellent at capturing these dependencies, there is often a lengthy task of figuring out how to combine those solutions into a docker image, as well as making decisions about which solution flavor to include. The kbash environment is useful in capturing this information, through the use of appropriate environment variables which are unique to a given sub-project. consistent scripting environment Many useful patterns in bash scripting are rather arcane. kbash wraps these in more intent-expressive labels. dynamic-reload Talk about kd reset and ACTIVATION_COUNT and prompt dynamic-assignment Talk about loading via Eval via boot.sh When not use make-replacement The kbash environment is not a make replacement yarn-replacement The kbash environment is not a yarn replacement npm-replacement The kbash environment is not a npm replacement lerna-replacement The kbash environment is not a lerna replacement How to use kbash for a PROJECT A project is a kbash environment coupled to a specific base directory, known internally as $VAR_PREFIX , where the VAR_PREFIX variable is the base of the $PROJECT . Keep in mind that VAR_PREFIX is not the name of the variable, rather it is the name of the name of the variable. So, for example, in the example above, the kb test project, the value of $KB will be the root of the project, and $KB/kbash will organize the specific bits of bash technology for the project. In additional, all internal state variables will be prefixed by KB test project, KXX is the VAR_PREFIX and $KXX evaluates to the base of the kx project. Commands and Functions Utility files and Language Support Components Concept and Purpose","title":"Getting Started"},{"location":"#quickstart","text":"The following commands verify that the system is operational. This sets up a new environment, runs a shell inside it, runs the default documentation command, and then exits the shell. git clone git@github.com:korsimoro/kbash ~/.kbash ~/.kbash/test/sanity.sh This will install a test environment and execute the entrypoint command to generate the default help output. Click here for example output You can find Documentation in the current docs directory, by opening the docs/index.html file with your local browser.","title":"Quickstart"},{"location":"#bootstrap","text":"Applying kbash to an existing project is easy. The following will add kbash support to your project, relying upon the global checkout for utility functions and separating project-specific configuration from generic utility core (typically in ~/.kbash ) git clone git@github.com:korsimoro/kbash ~/.kbash ~/.kbash/setup.sh <ENTRYPOINT> <VAR_PREFIX> <DIRECTORY> <DIRECTORY>/shell.sh The three variable listed above are described here: Argument Example Description ENTRYPOINT kb This is the name of the command introduced into the environment, and the prefix on all defined shell assets (functions, internal variables) VAR_PREFIX KB This is the prefix attached to all public variables used to describe and control the environment. DIRECTORY $PROJECT/kbash This is the directory in which the new, project specific, kbash environment is to be set up. Canonically it is in the kbash directory of your project. This directory exists in addition to the clone above.","title":"Bootstrap"},{"location":"#development-documentation","text":"If you are interested in developing or building kbash, please check out our Developers file. This talks about how to view and build the existing documentation. We use docker with MkDoc-Material","title":"Development &amp; Documentation"},{"location":"#a-cool-trick","text":"You can run a single command within a kbash environment, without influencing the external execution environment. echo \"kx manual\" | $BUILD_DOCS_BASE/../test/single.sh -i > $BUILD_DOCS_BASE/in/example-manual.md","title":"A Cool Trick"},{"location":"#what-is-kbash-and-how-would-i-use-it","text":"Many software projects, such as an npm package, or a python module, or a rust crate, or a ruby gem have sufficient support within the language environment for building and packaging code, for running tests, for linking documentation with the code base, etc. However, in complex, multi-language, multi-component projects, coordinating the different build environments often requires bits and pieces of glue which do not fit well in the language specific build systems. The kbash environment provides a way to organize those bits of logic as a set of shell functions and files. When rapidly investigating and hacking around multiple projects spanning diverse technology sets, it is often useful to write a one-off shell script that you expect to use once-or twice, but often wind up using for a while. The kbash environment is a Convention-based toolkit which organizes these one-off bits of knowledge, until such time as they can be integrated into the mainstream build environments - at which time the kbash environment should be pruned. kbash should be a value-added utility for temporary hacky-information capture, not a solution in itself. A final role of kbash is in capturing environmental integrity, sanity, and state checks. This is exactly the sort of utility you hope you never need, but which can greatly improve the ability to troubleshoot broken environments.","title":"What is kbash and how would I use it?"},{"location":"#concepts","text":"","title":"Concepts"},{"location":"#a-project","text":"A kbash project consists of - a kbash directory within the project - a checkout of the korsimoro/kbash common library, typically ~/.kbash The common library provides utility functions and scripts which are not related to any specific project. All project specific data is located in the kbash project directory, typically at $PROJECT/kbash","title":"A Project"},{"location":"#entrypoint-command-line-tool","text":"Every project has a command line tool with subcommands, much like git . Interestingly, kbash takes the form of a bash function, which allows it to manipulate the current environment variables in cases when it is useful to do so, such as activating a python virtual environment, a node virtual environment, or some combination of environments (for example, a project using both a python venv and an nvm environment).","title":"ENTRYPOINT command line tool"},{"location":"#commands-vs-functions","text":"A key distinction must be made between bash functions and commands. Commands are executed as subprocesses, like any other command - meaning that the environment of the executing child process is isolated from the running shell. A subcommand can not, for example, change the current prompt. Functions, on the other hand, run within the current shell and as such they can modify the current environment. This is exploited by many of the language specific virtual environment managers and modern bash provides a tremendous amount of support for such scripting. On the other hand, with great power comes great responsibility - so every attempt is made to minimize the use of functions and limit their use to cases in which a modification of the environment is necessary. A common example of this distinction are cd and ls - cd is a bash-builtin which operates on the current environment, while ls is just a program that needs to be in the PATH .","title":"Commands vs. Functions"},{"location":"#components","text":"A kbash project is usually made up of multiple parts which need to be coordinated, and often which have a common lifecycle. For example, one project where kbash proved useful, used forks of two lerna-based monorepo typescript projects, two forks of python projects, one mixed python/typescript project, one project that built all of the above into an electron deliverable. In this case, each project was modeled as a component. Declaring a component is done simply, using this form ENTRYPOINT add-component [name] [var-prefix] Which sets up the following structure - creating what needs to be created and using existing elements (like directories) if present: What Description $PROJECT/kbash/components/[name] The place for your component functions & commands ENTRYPOINT [name] .... The cli hook $PROJECT/[name] The directory containing the component ${var-prefix}_BASE Variable pointing to the $PROJECT/[name] directory other default variables look in $PROJECT/kbash/components/[name]/describe.sh ENTRYPOINT [cfunc] [name] see the table below","title":"Components"},{"location":"#standard-component-lifecycle","text":"Stage Description setup This performs functions like npm install , set up a python venv, install ruby gems, etc. clean This erases anything installed in setup activate This makes the environment constructed in setup the active environment describe This provides information about the environment build This triggers whatever is the standard build script for the component These are not strongly required - and, in fact, they are simply bash functions that get called and which obey a standard naming convention. The hope is that using add-component will pattern out a set of files, which can then be quickly edited, to capture the sort of information that is typically in the component's readme - for example, running npm install . In the table below, imagine that we have a project called ex with a single component called comp1 set up using: ~/.kbash/setup.sh ex EX /tmp/ex ex add-component comp1 COMP1 In this case, the following is set up CLI Function Where Defined ex build comp1 build_environment_ex_comp1 $EX/kbash/components/comp1/build.sh ex activate comp1 activate_environment_ex_comp1 $EX/kbash/components/comp1/activate.sh ex describe comp1 describe_environment_ex_comp1 $EX/kbash/components/comp1/describe.sh ex clean comp1 clean_environment_ex_comp1 $EX/kbash/components/comp1/clean.sh ex setup comp1 setup_environment_ex_comp1 $EX/kbash/components/comp1/setup.sh","title":"Standard Component Lifecycle"},{"location":"#old-notes","text":"","title":"Old Notes"},{"location":"#when-to-use","text":"project-discovery For mature projects, the roll of kbash should be reduced substantially. The kbash environment exists to support exploration, and the documented accretion of devops knowledge in the form of bash snippets, operating against a rich field of structure, utilities, and variables. multi-project If a project consists of a blending of multiple sub-projects, and the investigation of an complex build. Once the complex build is well understood, the knowledge accumulated in kbash scripts should be migrated into the more mature build systems of the sub-projects.","title":"When to use"},{"location":"#drivers","text":"environment-coupling Rather than being confined to operations on the filesystem, kbash allows systematic use of the shell environment. This is similar to - python venv - virtual environments for python - nvm - virtual environments for node - rvm - virtual environments for ruby Environmental coupling is accomplished through the use of bash function sets which are integrated into the control, help, and convention systems. multiple-concurrency Multiple kbash environments can co-exist, as all shell variables, including the entry point, are scoped by prefixes - ENTRYPOINT - this is the entrypoint, and is used to prefix all project specfic information. environment-isolation Often, when developing node or python systems, each has an active set of CLI entrypoints which are required by the repository. Many build systems rely on system deployments. While solutions like docker are excellent at capturing these dependencies, there is often a lengthy task of figuring out how to combine those solutions into a docker image, as well as making decisions about which solution flavor to include. The kbash environment is useful in capturing this information, through the use of appropriate environment variables which are unique to a given sub-project. consistent scripting environment Many useful patterns in bash scripting are rather arcane. kbash wraps these in more intent-expressive labels. dynamic-reload Talk about kd reset and ACTIVATION_COUNT and prompt dynamic-assignment Talk about loading via Eval via boot.sh","title":"Drivers"},{"location":"#when-not-use","text":"make-replacement The kbash environment is not a make replacement yarn-replacement The kbash environment is not a yarn replacement npm-replacement The kbash environment is not a npm replacement lerna-replacement The kbash environment is not a lerna replacement","title":"When not use"},{"location":"#how-to-use-kbash-for-a-project","text":"A project is a kbash environment coupled to a specific base directory, known internally as $VAR_PREFIX , where the VAR_PREFIX variable is the base of the $PROJECT . Keep in mind that VAR_PREFIX is not the name of the variable, rather it is the name of the name of the variable. So, for example, in the example above, the kb test project, the value of $KB will be the root of the project, and $KB/kbash will organize the specific bits of bash technology for the project. In additional, all internal state variables will be prefixed by KB test project, KXX is the VAR_PREFIX and $KXX evaluates to the base of the kx project.","title":"How to use kbash for a PROJECT"},{"location":"#commands-and-functions","text":"","title":"Commands and Functions"},{"location":"#utility-files-and-language-support","text":"","title":"Utility files and Language Support"},{"location":"#components_1","text":"","title":"Components"},{"location":"#concept-and-purpose","text":"","title":"Concept and Purpose"},{"location":"example-manual/","text":"kx kx [COMMAND] [help|--help|-help|-h|?] ... kx is a bash environment supporting development. Functions (modify the current shell) add-command Add a command to the kx environment. add-component Add a new component add-function Add a function. bundle Runs the project specific bundle cd cd /home/ewelton/Desktop/D/kbash/test/testdir/kx/[PATH] (or base w/o arg) deactivate Restores key variables to boot state kbash-env Display current environment settings. kbash-os Display os kbash-troff disable KBASH_TRACE kbash-tron set KBASH_TRACE to trace KBASH internals parallel Control how many jobs run in parallel. reset Reload the environment. troff Stop bash execution trace. tron Start bash execution trace. Commands (run as subprocesses) about Detailed Information about KBASH component-list List all available components klang Manage KBASH top level languages manual Generate help manual No components configured, use kx add-component to add components. Use kx [FUNCTION|COMMAND|COMPONENT] help for more information. Functions Functions manipulate the local shell variables, unlike commands, which are executed by the shell as a subprocess. add-command kx add_command [help|--help|-help|-h|?] COMMAND_NAME Add a command to the kx environment. This will create the file /home/ewelton/Desktop/D/kbash/test/testdir/kx/kbash/commands/[COMMAND_NAME].sh if it does not exist. You should then edit this file to implement. The template file used in creation is located at /home/ewelton/Desktop/D/kbash/setup/command.sh You will want to edit 3 things 1. The oneline help summary that is used in other contexts 2. The print_help() function, which is the detailed help 3. The run() function, which is executed as a subprocess add-component kx add_component [help|--help|-help|-h|?] [COMPONENT] [KXX] Add a new component This will set up a component. add-function kx add_function [help|--help|-help|-h|?] FUNCTION_NAME Add a function. This will create the file /home/ewelton/Desktop/D/kbash/test/testdir/kx/kbash/functions/[FUNCTION_NAME].sh if it does not exist. You should then edit this file to implement. The template file used in creation is located at /home/ewelton/Desktop/D/kbash/setup/function.sh You will want to edit the 4 function stubs 1. oneline_help_kx_[FUNCTION_NAME] 2. cmdline_help_kx_[FUNCTION_NAME] 3. help_kx_[FUNCTION_NAME] 4. run_kx_[FUNCTION_NAME] bundle kx bundle [help|--help|-help|-h|?] [Bundle Commend Line] Runs the project specific bundle This runs the correctly scoped bundle - ruby requires a complete path to the bundle wrapper in order to set the environment correctly. cd kx cd [help|--help|-help|-h|?] [PATH] cd /home/ewelton/Desktop/D/kbash/test/testdir/kx/[PATH] (or base w/o arg) This is a shell function, which execute cd as follows: cd /home/ewelton/Desktop/D/kbash/test/testdir/kx/[PATH]. If no PATH is provided, this just cds into cd /home/ewelton/Desktop/D/kbash/test/testdir/kx deactivate kx deactivate [help|--help|-help|-h|?] Restores key variables to boot state kbash-env kx kbash_env [help|--help|-help|-h|?] Display current environment settings. kx env kbash-os kx kbash_os [help|--help|-help|-h|?] Display os This command will report what the kbash utilities think the current operating system is. You can use the following functions in the shell environment (or your own) scripts, if you want a quick check to determine your operating system - is_osx - is_linux - is_windows This is based off of uname - so. You can use kbash-os to show you the uname output and check the value so is_osx, is_linux, is_windows For example: > kx kbash-os Checking os: uname ='Linux kisia 4.15.0-48-generic #51-Ubuntu SMP Wed Apr 3 08:28:49 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux' Linux Detected > kbash-troff kx kbash_troff [help|--help|-help|-h|?] disable KBASH_TRACE This is equivalent to export KBASH_TRACE=false kbash-tron kx kbash_tron [help|--help|-help|-h|?] set KBASH_TRACE to trace KBASH internals This is equivalent to export KBASH_TRACE=true parallel kx parallel [help|--help|-help|-h|?] MAXJOBS Control how many jobs run in parallel. Control how many jobs run in parallel reset kx reset [help|--help|-help|-h|?] Reload the environment. In this shell, execute: /home/ewelton/Desktop/D/kbash/test/testdir/kx/activate.sh This will cause the entire kx runtime to be reloaded, so any changes to functions or commands will be processed. This will update the activation count from 0 to 1 troff kx troff [help|--help|-help|-h|?] Stop bash execution trace. Equivalent to set +x tron kx tron [help|--help|-help|-h|?] Start bash execution trace. Equivalent to set -x 5 Commands about kx <command> [help] kx is a bash environment supporting development. kx is pure anti-pattern, in includes - 'within-environment' mutations- bash functions allow forward mutation of the active environment, with no guarantees of any stable state, save the single application of this function after a clean reset - pure 'side-effect' focus. This is an attempt to identify mutators to the filesystem, and to codify them. All functions and commands in the environment are expected to operate upon the filesystem directly. git provides us exceptional visiblity into changes over the active checkout. kx supports the development of ad-hoc tasks required to effectively build a complex, multi-project system. As knowledge is captured w/in the kx script system, it is added into the compiled node or python build support tools. But when you have to adapt to an existing culture, as in a fork, you need a little grease. The node and python knowledge is the organized grease to glue a complete system onto a consistent base. kx uses a \"Convention over Configuration\" and heavily seeds a bash operating environment with functions and variables, supporting multi-tech integration projects. The ability to \"regenerate\" the environment from the kx reset command means that scripts can be rapidly edited and applied - recorded in a pull-request, and the collective wisdom knitting forward. kx can be rapidly and ad-hoc adjusted, and it is specific to this repository. The bashenv orchestrates the connection of the environment with a conversational mutator - a live bash shell. As this is bound to a repository top, the space underneath is managed - so this is effectively a bash shell over a commit-trail of reference. kx is scoped by directory (or checkout) - based on the KXX variable. KXX = /home/ewelton/Desktop/D/kbash/test/testdir/kx For more information, check out this file: /home/ewelton/Desktop/D/kbash/test/testdir/kx/docs/bashenv.md In general use kx [cmd] help for more information. component-list Show component list klang kx klang kx [LANG] .... Manage languages Commands (run as subprocesses) node System Node python Manage python configuration ruby System Node node kx klang/node kx node [LANG] .... Manage Local Node python kx klang/python kx klang python [LANG] .... inspect the local python environment Commands (run as subprocesses) info System python information info Command not found - no 'info help' in 'project/klang/python' ruby kx klang/ruby kx ruby [LANG] .... Manage Local Ruby Commands (run as subprocesses) cleanrvm Detailed Information about KBASH info Where installrvm Detailed Information about KBASH resetrvm Detailed Information about KBASH cleanrvm Command not found - no 'cleanrvm help' in 'project/klang/ruby' info Command not found - no 'info help' in 'project/klang/ruby' installrvm Command not found - no 'installrvm help' in 'project/klang/ruby' resetrvm Command not found - no 'resetrvm help' in 'project/klang/ruby' manual Recursively assemble documentation as a markdown file. About kx <command> [help] kx is a bash environment supporting development. kx is pure anti-pattern, in includes - 'within-environment' mutations- bash functions allow forward mutation of the active environment, with no guarantees of any stable state, save the single application of this function after a clean reset - pure 'side-effect' focus. This is an attempt to identify mutators to the filesystem, and to codify them. All functions and commands in the environment are expected to operate upon the filesystem directly. git provides us exceptional visiblity into changes over the active checkout. kx supports the development of ad-hoc tasks required to effectively build a complex, multi-project system. As knowledge is captured w/in the kx script system, it is added into the compiled node or python build support tools. But when you have to adapt to an existing culture, as in a fork, you need a little grease. The node and python knowledge is the organized grease to glue a complete system onto a consistent base. kx uses a \"Convention over Configuration\" and heavily seeds a bash operating environment with functions and variables, supporting multi-tech integration projects. The ability to \"regenerate\" the environment from the kx reset command means that scripts can be rapidly edited and applied - recorded in a pull-request, and the collective wisdom knitting forward. kx can be rapidly and ad-hoc adjusted, and it is specific to this repository. The bashenv orchestrates the connection of the environment with a conversational mutator - a live bash shell. As this is bound to a repository top, the space underneath is managed - so this is effectively a bash shell over a commit-trail of reference. kx is scoped by directory (or checkout) - based on the KXX variable. KXX = /home/ewelton/Desktop/D/kbash/test/testdir/kx For more information, check out this file: /home/ewelton/Desktop/D/kbash/test/testdir/kx/docs/bashenv.md In general use kx [cmd] help for more information.","title":"Manual"},{"location":"example-manual/#kx","text":"kx [COMMAND] [help|--help|-help|-h|?] ... kx is a bash environment supporting development. Functions (modify the current shell) add-command Add a command to the kx environment. add-component Add a new component add-function Add a function. bundle Runs the project specific bundle cd cd /home/ewelton/Desktop/D/kbash/test/testdir/kx/[PATH] (or base w/o arg) deactivate Restores key variables to boot state kbash-env Display current environment settings. kbash-os Display os kbash-troff disable KBASH_TRACE kbash-tron set KBASH_TRACE to trace KBASH internals parallel Control how many jobs run in parallel. reset Reload the environment. troff Stop bash execution trace. tron Start bash execution trace. Commands (run as subprocesses) about Detailed Information about KBASH component-list List all available components klang Manage KBASH top level languages manual Generate help manual No components configured, use kx add-component to add components. Use kx [FUNCTION|COMMAND|COMPONENT] help for more information.","title":"kx"},{"location":"example-manual/#functions","text":"Functions manipulate the local shell variables, unlike commands, which are executed by the shell as a subprocess.","title":"Functions"},{"location":"example-manual/#add-command","text":"kx add_command [help|--help|-help|-h|?] COMMAND_NAME Add a command to the kx environment. This will create the file /home/ewelton/Desktop/D/kbash/test/testdir/kx/kbash/commands/[COMMAND_NAME].sh if it does not exist. You should then edit this file to implement. The template file used in creation is located at /home/ewelton/Desktop/D/kbash/setup/command.sh You will want to edit 3 things 1. The oneline help summary that is used in other contexts 2. The print_help() function, which is the detailed help 3. The run() function, which is executed as a subprocess","title":"add-command"},{"location":"example-manual/#add-component","text":"kx add_component [help|--help|-help|-h|?] [COMPONENT] [KXX] Add a new component This will set up a component.","title":"add-component"},{"location":"example-manual/#add-function","text":"kx add_function [help|--help|-help|-h|?] FUNCTION_NAME Add a function. This will create the file /home/ewelton/Desktop/D/kbash/test/testdir/kx/kbash/functions/[FUNCTION_NAME].sh if it does not exist. You should then edit this file to implement. The template file used in creation is located at /home/ewelton/Desktop/D/kbash/setup/function.sh You will want to edit the 4 function stubs 1. oneline_help_kx_[FUNCTION_NAME] 2. cmdline_help_kx_[FUNCTION_NAME] 3. help_kx_[FUNCTION_NAME] 4. run_kx_[FUNCTION_NAME]","title":"add-function"},{"location":"example-manual/#bundle","text":"kx bundle [help|--help|-help|-h|?] [Bundle Commend Line] Runs the project specific bundle This runs the correctly scoped bundle - ruby requires a complete path to the bundle wrapper in order to set the environment correctly.","title":"bundle"},{"location":"example-manual/#cd","text":"kx cd [help|--help|-help|-h|?] [PATH] cd /home/ewelton/Desktop/D/kbash/test/testdir/kx/[PATH] (or base w/o arg) This is a shell function, which execute cd as follows: cd /home/ewelton/Desktop/D/kbash/test/testdir/kx/[PATH]. If no PATH is provided, this just cds into cd /home/ewelton/Desktop/D/kbash/test/testdir/kx","title":"cd"},{"location":"example-manual/#deactivate","text":"kx deactivate [help|--help|-help|-h|?] Restores key variables to boot state","title":"deactivate"},{"location":"example-manual/#kbash-env","text":"kx kbash_env [help|--help|-help|-h|?] Display current environment settings. kx env","title":"kbash-env"},{"location":"example-manual/#kbash-os","text":"kx kbash_os [help|--help|-help|-h|?] Display os This command will report what the kbash utilities think the current operating system is. You can use the following functions in the shell environment (or your own) scripts, if you want a quick check to determine your operating system - is_osx - is_linux - is_windows This is based off of uname - so. You can use kbash-os to show you the uname output and check the value so is_osx, is_linux, is_windows For example: > kx kbash-os Checking os: uname ='Linux kisia 4.15.0-48-generic #51-Ubuntu SMP Wed Apr 3 08:28:49 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux' Linux Detected >","title":"kbash-os"},{"location":"example-manual/#kbash-troff","text":"kx kbash_troff [help|--help|-help|-h|?] disable KBASH_TRACE This is equivalent to export KBASH_TRACE=false","title":"kbash-troff"},{"location":"example-manual/#kbash-tron","text":"kx kbash_tron [help|--help|-help|-h|?] set KBASH_TRACE to trace KBASH internals This is equivalent to export KBASH_TRACE=true","title":"kbash-tron"},{"location":"example-manual/#parallel","text":"kx parallel [help|--help|-help|-h|?] MAXJOBS Control how many jobs run in parallel. Control how many jobs run in parallel","title":"parallel"},{"location":"example-manual/#reset","text":"kx reset [help|--help|-help|-h|?] Reload the environment. In this shell, execute: /home/ewelton/Desktop/D/kbash/test/testdir/kx/activate.sh This will cause the entire kx runtime to be reloaded, so any changes to functions or commands will be processed. This will update the activation count from 0 to 1","title":"reset"},{"location":"example-manual/#troff","text":"kx troff [help|--help|-help|-h|?] Stop bash execution trace. Equivalent to set +x","title":"troff"},{"location":"example-manual/#tron","text":"kx tron [help|--help|-help|-h|?] Start bash execution trace. Equivalent to set -x 5","title":"tron"},{"location":"example-manual/#commands","text":"","title":"Commands"},{"location":"example-manual/#about","text":"kx <command> [help] kx is a bash environment supporting development. kx is pure anti-pattern, in includes - 'within-environment' mutations- bash functions allow forward mutation of the active environment, with no guarantees of any stable state, save the single application of this function after a clean reset - pure 'side-effect' focus. This is an attempt to identify mutators to the filesystem, and to codify them. All functions and commands in the environment are expected to operate upon the filesystem directly. git provides us exceptional visiblity into changes over the active checkout. kx supports the development of ad-hoc tasks required to effectively build a complex, multi-project system. As knowledge is captured w/in the kx script system, it is added into the compiled node or python build support tools. But when you have to adapt to an existing culture, as in a fork, you need a little grease. The node and python knowledge is the organized grease to glue a complete system onto a consistent base. kx uses a \"Convention over Configuration\" and heavily seeds a bash operating environment with functions and variables, supporting multi-tech integration projects. The ability to \"regenerate\" the environment from the kx reset command means that scripts can be rapidly edited and applied - recorded in a pull-request, and the collective wisdom knitting forward. kx can be rapidly and ad-hoc adjusted, and it is specific to this repository. The bashenv orchestrates the connection of the environment with a conversational mutator - a live bash shell. As this is bound to a repository top, the space underneath is managed - so this is effectively a bash shell over a commit-trail of reference. kx is scoped by directory (or checkout) - based on the KXX variable. KXX = /home/ewelton/Desktop/D/kbash/test/testdir/kx For more information, check out this file: /home/ewelton/Desktop/D/kbash/test/testdir/kx/docs/bashenv.md In general use kx [cmd] help for more information.","title":"about"},{"location":"example-manual/#component-list","text":"Show component list","title":"component-list"},{"location":"example-manual/#klang","text":"kx klang kx [LANG] .... Manage languages Commands (run as subprocesses) node System Node python Manage python configuration ruby System Node","title":"klang"},{"location":"example-manual/#manual","text":"Recursively assemble documentation as a markdown file.","title":"manual"},{"location":"example-manual/#about_1","text":"kx <command> [help] kx is a bash environment supporting development. kx is pure anti-pattern, in includes - 'within-environment' mutations- bash functions allow forward mutation of the active environment, with no guarantees of any stable state, save the single application of this function after a clean reset - pure 'side-effect' focus. This is an attempt to identify mutators to the filesystem, and to codify them. All functions and commands in the environment are expected to operate upon the filesystem directly. git provides us exceptional visiblity into changes over the active checkout. kx supports the development of ad-hoc tasks required to effectively build a complex, multi-project system. As knowledge is captured w/in the kx script system, it is added into the compiled node or python build support tools. But when you have to adapt to an existing culture, as in a fork, you need a little grease. The node and python knowledge is the organized grease to glue a complete system onto a consistent base. kx uses a \"Convention over Configuration\" and heavily seeds a bash operating environment with functions and variables, supporting multi-tech integration projects. The ability to \"regenerate\" the environment from the kx reset command means that scripts can be rapidly edited and applied - recorded in a pull-request, and the collective wisdom knitting forward. kx can be rapidly and ad-hoc adjusted, and it is specific to this repository. The bashenv orchestrates the connection of the environment with a conversational mutator - a live bash shell. As this is bound to a repository top, the space underneath is managed - so this is effectively a bash shell over a commit-trail of reference. kx is scoped by directory (or checkout) - based on the KXX variable. KXX = /home/ewelton/Desktop/D/kbash/test/testdir/kx For more information, check out this file: /home/ewelton/Desktop/D/kbash/test/testdir/kx/docs/bashenv.md In general use kx [cmd] help for more information.","title":"About"},{"location":"example-outputs/","text":"Example Outputs sanity git clone git@github.com:korsimoro/kbash ~/.kbash ~/.kbash/test/sanity.sh Korismoro:test$ ./sanity.sh kx[0]:kx> kx kx [COMMAND] [help|--help|-help|-h|?] ... kx is a bash environment supporting development. Functions (modify the current shell) cd cd /home/ewelton/Desktop/korsimoro/utilities/k-bashenv/test/testdir/kx/[PATH] (or base w/o arg) component-list List components, if any. component-new cd home, or into /home/ewelton/Desktop/korsimoro/utilities/k-bashenv/test/testdir/kx/[C]. kbash-env Display current environment settings. kbash-troff disable KBASH_TRACE kbash-tron set KBASH_TRACE to trace KBASH internals parallel Control how many jobs run in parallel. reset Reload the environment. troff Stop bash execution trace. tron Start bash execution trace. Print K-Bash Commands Commands about manual Generate help manual script Execute a script of kd commands update Just fetch updates Command Groups node The KIT Workbench Documentation Environment python The KIT Workbench Documentation Environment ruby The KIT Workbench Documentation Environment No components configured, use kx component-new to add components. Use kx COMMAND help for more information. kx[0]:kx> exit Korismoro:test$","title":"Output"},{"location":"example-outputs/#example-outputs","text":"","title":"Example Outputs"},{"location":"example-outputs/#sanity","text":"git clone git@github.com:korsimoro/kbash ~/.kbash ~/.kbash/test/sanity.sh Korismoro:test$ ./sanity.sh kx[0]:kx> kx kx [COMMAND] [help|--help|-help|-h|?] ... kx is a bash environment supporting development. Functions (modify the current shell) cd cd /home/ewelton/Desktop/korsimoro/utilities/k-bashenv/test/testdir/kx/[PATH] (or base w/o arg) component-list List components, if any. component-new cd home, or into /home/ewelton/Desktop/korsimoro/utilities/k-bashenv/test/testdir/kx/[C]. kbash-env Display current environment settings. kbash-troff disable KBASH_TRACE kbash-tron set KBASH_TRACE to trace KBASH internals parallel Control how many jobs run in parallel. reset Reload the environment. troff Stop bash execution trace. tron Start bash execution trace. Print K-Bash Commands Commands about manual Generate help manual script Execute a script of kd commands update Just fetch updates Command Groups node The KIT Workbench Documentation Environment python The KIT Workbench Documentation Environment ruby The KIT Workbench Documentation Environment No components configured, use kx component-new to add components. Use kx COMMAND help for more information. kx[0]:kx> exit Korismoro:test$","title":"sanity"},{"location":"layout/","text":"Repository Layout Subdirectories Dir Purpose api Subsystem exposed in consumer shells core Core bash abilities docs Documentation shipped on public site lang Specific Language Support (node, python, ruby, etc....) mkdocs Source for site docs setup Templates used in new environments test Utilities supporting test Executable Files File Purpose boot.sh Invoke to activate custom environment setup.sh Use to set up a new environment Utility Files Fjle Purpose os.sh Specific OS/Bash level adaptations Control Files Fjle Purpose README.md Use to set up a new environment LICENSE not yet present","title":"Layout"},{"location":"layout/#repository-layout","text":"","title":"Repository Layout"},{"location":"layout/#subdirectories","text":"Dir Purpose api Subsystem exposed in consumer shells core Core bash abilities docs Documentation shipped on public site lang Specific Language Support (node, python, ruby, etc....) mkdocs Source for site docs setup Templates used in new environments test Utilities supporting test","title":"Subdirectories"},{"location":"layout/#executable-files","text":"File Purpose boot.sh Invoke to activate custom environment setup.sh Use to set up a new environment","title":"Executable Files"},{"location":"layout/#utility-files","text":"Fjle Purpose os.sh Specific OS/Bash level adaptations","title":"Utility Files"},{"location":"layout/#control-files","text":"Fjle Purpose README.md Use to set up a new environment LICENSE not yet present","title":"Control Files"},{"location":"ops/","text":"Theory of Operation $PROJECT specific activation What happens Activate a shell by executing . $PROJECT/activate.sh , which applies the environment to the current shell, or $PROJECT/shell.sh which spawns a subshell with the $PROJECT environment activated. The . $PROJECT/activate.sh command sets the project base directory and invokes $KBASH/util/api/boot.sh . Sourcing boot.sh causes the following to occur, where all shell input files are sed filtered to replace two strings: ENTRYPOINT , which is used to prefix all kbash environment elements. For example, if your entrypoint is kx then all of the functions involved in this environment should be prefixed with kx_ . Access to the environment is then acquired by running commands prefixed with kx , such as kx build project3 VAR_PREFIX , which is used to scope all variables associated with the top level build environment. Often, the ENTRYPOINT does not scan well in variable assignments. In the kx test case, the value of VAR_PREFIX is KXX , meaning that all environment variables associated with the $PROJECT are prefixed with KXX_ The following global variables are set during invocation Pos Variable Purpose $1 ENTRYPOINT scopes functions $2 VAR_PREFIX scopes variables $3 USER_UTIL_LOAD_LIST loaded, in order, from $PROJECT $4 LANG_LOAD_LIST loaded, in order, from $KBASH","title":"Theory of Operation"},{"location":"ops/#theory-of-operation","text":"","title":"Theory of Operation"},{"location":"ops/#project-specific-activation","text":"","title":"$PROJECT specific activation"},{"location":"ops/#what-happens","text":"Activate a shell by executing . $PROJECT/activate.sh , which applies the environment to the current shell, or $PROJECT/shell.sh which spawns a subshell with the $PROJECT environment activated. The . $PROJECT/activate.sh command sets the project base directory and invokes $KBASH/util/api/boot.sh . Sourcing boot.sh causes the following to occur, where all shell input files are sed filtered to replace two strings: ENTRYPOINT , which is used to prefix all kbash environment elements. For example, if your entrypoint is kx then all of the functions involved in this environment should be prefixed with kx_ . Access to the environment is then acquired by running commands prefixed with kx , such as kx build project3 VAR_PREFIX , which is used to scope all variables associated with the top level build environment. Often, the ENTRYPOINT does not scan well in variable assignments. In the kx test case, the value of VAR_PREFIX is KXX , meaning that all environment variables associated with the $PROJECT are prefixed with KXX_ The following global variables are set during invocation Pos Variable Purpose $1 ENTRYPOINT scopes functions $2 VAR_PREFIX scopes variables $3 USER_UTIL_LOAD_LIST loaded, in order, from $PROJECT $4 LANG_LOAD_LIST loaded, in order, from $KBASH","title":"What happens"},{"location":"api/commands/","text":"These will be searched for and loaded on demand","title":"Commands"},{"location":"api/commands/#these-will-be-searched-for-and-loaded-on-demand","text":"","title":"These will be searched for and loaded on demand"},{"location":"api/component/","text":"These will be searched for and loaded on demand","title":"These will be searched for and loaded on demand"},{"location":"api/component/#these-will-be-searched-for-and-loaded-on-demand","text":"","title":"These will be searched for and loaded on demand"},{"location":"api/functions/","text":"these are loaded into the shell","title":"Functions"},{"location":"api/functions/#these-are-loaded-into-the-shell","text":"","title":"these are loaded into the shell"},{"location":"api/heavy-component/","text":"These will be searched for and loaded on demand","title":"These will be searched for and loaded on demand"},{"location":"api/heavy-component/#these-will-be-searched-for-and-loaded-on-demand","text":"","title":"These will be searched for and loaded on demand"},{"location":"api/intro/","text":"api The API is defined by - ENTRYPOINT - VAR_PREFIX Variables Where Set Variable Value VAR_PREFIX $( cd \"$( dirname \"${BASH_SOURCE[0]}\" )/..\" && pwd ) VAR_PREFIX_KBASH $KBASH/api/util/kbash/state.sh VAR_PREFIX_KBASH_LOGS $KBASH/api/util/kbash/state.sh VAR_PREFIX_KBASH_COMMAND $KBASH/api/util/kbash/state.sh VAR_PREFIX_FUNCTION_LIST $KBASH/api/util/kbash/state.sh VAR_PREFIX_KBASH_FUNCTION $KBASH/api/util/kbash/state.sh VAR_PREFIX_COMPONENT_LIST $KBASH/api/util/kbash/state.sh VAR_PREFIX_COMPONENT_DIR $KBASH/api/util/kbash/state.sh Initial Values Variable Value VAR_PREFIX $( cd \"$( dirname \"${BASH_SOURCE[0]}\" )/..\" && pwd ) VAR_PREFIX_KBASH $VAR_PREFIX/bashenv VAR_PREFIX_KBASH_LOGS $VAR_PREFIX/kbash-logs VAR_PREFIX_KBASH_COMMAND $VAR_PREFIX_KBASH/commands VAR_PREFIX_FUNCTION_LIST VAR_PREFIX_KBASH_FUNCTION $VAR_PREFIX_KBASH/functions VAR_PREFIX_COMPONENT_LIST VAR_PREFIX_COMPONENT_DIR $VAR_PREFIX_KBASH/components api/boot.sh boot.sh is invoked with 4 positional arguments . <path-to-project-local-activate.sh> \\ \"ENTRYPOINT\" \\ \"VAR_PREFIX\" \\ \"USER_UTIL_LOAD_LIST\" \\ \"SYSTEM_UTIL_LOAD_LIST\" About ENTRYPOINT The shell prefix is the command line entry point used to access this environment. It is also used to scope all functions loaded into the shell. api/commands","title":"Intro"},{"location":"api/intro/#api","text":"The API is defined by - ENTRYPOINT - VAR_PREFIX","title":"api"},{"location":"api/intro/#variables","text":"","title":"Variables"},{"location":"api/intro/#where-set","text":"Variable Value VAR_PREFIX $( cd \"$( dirname \"${BASH_SOURCE[0]}\" )/..\" && pwd ) VAR_PREFIX_KBASH $KBASH/api/util/kbash/state.sh VAR_PREFIX_KBASH_LOGS $KBASH/api/util/kbash/state.sh VAR_PREFIX_KBASH_COMMAND $KBASH/api/util/kbash/state.sh VAR_PREFIX_FUNCTION_LIST $KBASH/api/util/kbash/state.sh VAR_PREFIX_KBASH_FUNCTION $KBASH/api/util/kbash/state.sh VAR_PREFIX_COMPONENT_LIST $KBASH/api/util/kbash/state.sh VAR_PREFIX_COMPONENT_DIR $KBASH/api/util/kbash/state.sh","title":"Where Set"},{"location":"api/intro/#initial-values","text":"Variable Value VAR_PREFIX $( cd \"$( dirname \"${BASH_SOURCE[0]}\" )/..\" && pwd ) VAR_PREFIX_KBASH $VAR_PREFIX/bashenv VAR_PREFIX_KBASH_LOGS $VAR_PREFIX/kbash-logs VAR_PREFIX_KBASH_COMMAND $VAR_PREFIX_KBASH/commands VAR_PREFIX_FUNCTION_LIST VAR_PREFIX_KBASH_FUNCTION $VAR_PREFIX_KBASH/functions VAR_PREFIX_COMPONENT_LIST VAR_PREFIX_COMPONENT_DIR $VAR_PREFIX_KBASH/components","title":"Initial Values"},{"location":"api/intro/#apibootsh","text":"boot.sh is invoked with 4 positional arguments . <path-to-project-local-activate.sh> \\ \"ENTRYPOINT\" \\ \"VAR_PREFIX\" \\ \"USER_UTIL_LOAD_LIST\" \\ \"SYSTEM_UTIL_LOAD_LIST\" About ENTRYPOINT The shell prefix is the command line entry point used to access this environment. It is also used to scope all functions loaded into the shell.","title":"api/boot.sh"},{"location":"api/intro/#apicommands","text":"","title":"api/commands"},{"location":"api/util/","text":"these provide support utilities","title":"Util"},{"location":"api/util/#these-provide-support-utilities","text":"","title":"these provide support utilities"}]}